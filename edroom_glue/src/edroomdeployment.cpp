//##############################################################################
//###############     This file has been generated by EDROOM     ###############
//##############################################################################
//broker1

#include <edroom_glue/edroomdeployment.h>

//*****************************************************************************
//Main Wait

void MainWait(ICUASW   &icuasw,
		CCEPDManager   &ccepdmanager,
		CCTM_ChannelCtrl   &cctm_channelctrl,
		RCCHK_FDIRMng   &rcchk_fdirmng,
		RCCBKGTCExec   &rccbkgtcexec){

	Pr_Time waitTime(3, 0);

#ifdef _EDROOM_SYSTEM_CLOSE
	while(!icuasw.EDROOMIsComponentFinished()
			||!ccepdmanager.EDROOMIsComponentFinished()
			||!cctm_channelctrl.EDROOMIsComponentFinished()
			||!rcchk_fdirmng.EDROOMIsComponentFinished()
			||!rccbkgtcexec.EDROOMIsComponentFinished())
#else
		while(true)
#endif


			Pr_DelayIn(waitTime);
}

//*****************************************************************************
//SetMemory

void CEDROOMSystemMemory::SetMemory(){

	icuaswMemory.SetMemory(10, icuaswMessages, &icuaswMessagesMarks[0]
	                                                             ,13,icuaswQueueNodes, &icuaswQueueNodesMarks[0]);
	ccepdmanagerMemory.SetMemory(10, ccepdmanagerMessages, &ccepdmanagerMessagesMarks[0]
	                                                             ,11,ccepdmanagerQueueNodes, &ccepdmanagerQueueNodesMarks[0]);
	cctm_channelctrlMemory.SetMemory(10, cctm_channelctrlMessages, &cctm_channelctrlMessagesMarks[0]
	                                                             ,10,cctm_channelctrlQueueNodes, &cctm_channelctrlQueueNodesMarks[0]);
	rcchk_fdirmngMemory.SetMemory(10, rcchk_fdirmngMessages, &rcchk_fdirmngMessagesMarks[0]
	                                                             ,14,rcchk_fdirmngQueueNodes, &rcchk_fdirmngQueueNodesMarks[0]);
	rccbkgtcexecMemory.SetMemory(10, rccbkgtcexecMessages, &rccbkgtcexecMessagesMarks[0]
	                                                             ,11,rccbkgtcexecQueueNodes, &rccbkgtcexecQueueNodesMarks[0]);
}


//*****************************************************************************
//CEDROOMSystemCommSAP
//*****************************************************************************

//Components

ICUASW   * CEDROOMSystemCommSAP::mp_icuasw=NULL;
CCEPDManager   * CEDROOMSystemCommSAP::mp_ccepdmanager=NULL;
CCTM_ChannelCtrl   * CEDROOMSystemCommSAP::mp_cctm_channelctrl=NULL;
RCCHK_FDIRMng   * CEDROOMSystemCommSAP::mp_rcchk_fdirmng=NULL;
RCCBKGTCExec   *CEDROOMSystemCommSAP:: mp_rccbkgtcexec=NULL;

//! Event for trigger the bottom half associated to the IRQ
Pr_IRQEvent	CEDROOMSystemCommSAP::RemoteCommEventIRQ(0x1D);

//! Binary Semaphore for signal the end of the bottom half of the IRQ
Pr_SemaphoreBin	CEDROOMSystemCommSAP::RemoteCommSemEndIRQ(0);

//**************************************************************************************************
//**************Function to get the information of the msg with the most priority*******************
void GetMaxPrioMsgInfo(uint8_t* msgPrio, uint8_t* msgSenderCmp, uint8_t* msgSenderCmpInterface, uint8_t* msgSignal){
	uint8_t aux_prio;
	uint32_t ID_CANMSG = edroom_can_drv_get_id(&aux_prio);
	*msgPrio = aux_prio;
	*msgSenderCmp = (ID_CANMSG>>16) & 0x0000007F;
	*msgSenderCmpInterface = (ID_CANMSG>>10) & 0x0000003F;
	*msgSignal = ID_CANMSG & 0x000003FF;
}


//! IRQ Handler for the IRQ
Pr_IRQHandler_RetType	CEDROOMSystemCommSAP::RemoteCommIRQHandler(void)
{
	uint8_t msg_completed = 0;
	//IRQ Handler
	msg_completed = pi_free_can_irq_handler();
	
	if(msg_completed) RemoteCommEventIRQ.Signal();

}

//! Bottom Half Task Function for the IRQ
Pr_TaskRV_t 	CEDROOMSystemCommSAP::RemoteCommIRQBottomHalfTask(Pr_TaskP_t){


	bool endTask=false;

	do
	{

		RemoteCommEventIRQ.Wait();

		if(!RemoteCommSemEndIRQ.WaitCond()){

			uint8_t msgPrio;
			uint8_t msgSenderCmp;
			uint8_t msgSenderCmpInterface;
			uint8_t msgSignal;
			uint8_t flush_edroom = 0; //=0 in case of error in msg, it wont be flushed

			//DEBUG
			//pdmcan_drv_read_status();

			//ID[28:25] aux->mp_ReceiverCmp->m_NomPriority; //4 bits
			//ID[24:23] 2 bits tipo de mensaje
			//ID[22:16] 7 bits aux->mp_SenderCmp->m_ComponentID;
			//ID[15:10] 6 bits aux->mp_SenderPort->m_IdInterface;
			//ID[9:0] 10 bits SHK_FDIR_TC
			// ********************************
			// Handling CAN IRQ vector 0x1C
			//TODO: Añadir función de PDMCAN, leer identificador.
			
			GetMaxPrioMsgInfo(&msgPrio, &msgSenderCmp,&msgSenderCmpInterface,&msgSignal);

			/* El siguiente código se genera en función del identificador del sender remoto, que lo tenemos fijado en Config (más abajo)
			 * void CEDROOMSystemDeployment_Node1::Config(ICUASW   *p_icuasw,
											CCEPDManager   *p_ccepdmanager,
											CCTM_ChannelCtrl   *p_cctm_channelctrl,
											RCCHK_FDIRMng   *p_rcchk_fdirmng,
											RCCBKGTCExec   *p_rccbkgtcexec){
			 */
			switch (msgSenderCmp){//Who sent the message?

			   case(4): //HK_FDIRMng sent it

					/* Para determinar la interfaz analizamos este código que se genera  para CEDROOMSystemCommSAP::RegisterInterfaces(
					m_localCommSAP.RegisterInterface(2, mp_rcchk_fdirmng->TMChannelCtrl, mp_rcchk_fdirmng);
					//m_localCommSAP.RegisterInterface(3, mp_rcchk_fdirmng->HK_FDIRTimer, mp_rcchk_fdirmng);
											 */
						switch(msgSenderCmpInterface){//What interface was used?
						  case(1): //interface EPDManager-HKFDIRMng (Asynchronous)

								switch(msgSignal){//What is the signal?

									case(RCCHK_FDIRMng::SRecAction):{
										//Read the data of the msg
										uint32_t elementsize = mp_rcchk_fdirmng->EDROOMPoolCDRecovAction.GetElementSize();
										CDRecovAction	* pData=mp_rcchk_fdirmng->EDROOMPoolCDRecovAction.AllocData();
										int32_t msgSize = edroom_can_drv_read_edroom_message(msgPrio, (uint8_t *) pData, elementsize, flush_edroom);
										if(msgSize<=0 || (uint32_t)msgSize != elementsize)
										{
											//Error case, msg size is wrong
											printf("Error: Wrong msgSize from system bus\n");
											mp_rcchk_fdirmng->EDROOMPoolCDRecovAction.FreeData(pData);
										}
										//Send the message and the data. (send)
										mp_rcchk_fdirmng->HK_FDIRCtrl.send(msgSignal,pData,&mp_rcchk_fdirmng->EDROOMPoolCDRecovAction);

										//DEBUG
										//pdmcan_drv_read_status();
									}
									break;
									default:
										//Error in Remote Msg Reception
									break;
								}
						  break;
						  case(2):	//interface HKFDIRMng-TM_ChannelCtrl (Synchronous invoke)
								switch(msgSignal){

									case(RCCHK_FDIRMng::STxTM):{
										//Read the data of the msg
										uint32_t elementsize = mp_rcchk_fdirmng->EDROOMPoolCDTMList.GetElementSize();
										CDTMList * pData=mp_rcchk_fdirmng->EDROOMPoolCDTMList.AllocData();
										int32_t msgSize = edroom_can_drv_read_edroom_message(msgPrio,  (uint8_t *) pData, elementsize, flush_edroom);
										if(msgSize<=0 || (uint32_t)msgSize != elementsize)
											//Error case, msgSize is wrong
										{
											printf("Error: Wrong msgSize from system bus\n");
											mp_rcchk_fdirmng->EDROOMPoolCDTMList.FreeData(pData);
										}else{
											//Send the message and the data. (invoke)
											mp_rcchk_fdirmng->TMChannelCtrl.invoke_from_remote(msgSignal,pData,&mp_rcchk_fdirmng->EDROOMPoolCDTMList);
										}
										//DEBUG
										//pdmcan_drv_read_status();
									}
									break;
									default:
										//Error in Remote Msg Reception
									break;
								}
						  break;

						}

			   break;

			   case(5): //BKGTCExec Sent it
					/* Register Interface for Component 5
						m_localCommSAP.RegisterInterface(1, mp_rccbkgtcexec->BKGExecCtrl, mp_rccbkgtcexec);
						m_localCommSAP.RegisterInterface(2, mp_rccbkgtcexec->TMChannelCtrl, mp_rccbkgtcexec);
					*/
						switch(msgSenderCmpInterface)//What interface was used?
						{
						//case(1): NA --Interface EPDManager-BKGTCExec (Asynchronous). CURRENTLY This component does not send any signal

						case(2):// Interface BKGTCExec-TM_ChannelCtrl (Synchronous invoke)
								switch(msgSignal){

									case(RCCBKGTCExec::STxTM):{
										//Read the data of the msg
										uint32_t elementsize = mp_rccbkgtcexec->EDROOMPoolCDTMList.GetElementSize();
										CDTMList * pData=mp_rccbkgtcexec->EDROOMPoolCDTMList.AllocData();
										int32_t msgSize = edroom_can_drv_read_edroom_message(msgPrio,  (uint8_t *) pData, elementsize, flush_edroom);
										if(msgSize<= 0 || (uint32_t)msgSize != elementsize)
											//Error case, msgSize is wrong
										{
											printf("Error: Wrong msgSize from system bus\n");
											mp_rccbkgtcexec->EDROOMPoolCDTMList.FreeData(pData);
										}else{
										//Send the message and the data. (invoke)
										mp_rccbkgtcexec->TMChannelCtrl.invoke_from_remote(msgSignal,pData,&mp_rccbkgtcexec->EDROOMPoolCDTMList);
										}
										//DEBUG
										//pdmcan_drv_read_status();
									}
									break;
									default:
										//Error in Remote Msg Reception
									break;

								}
						break;
						}

				break;

				default:
					//Error in Remote Msg Reception
					break;

			}


			Pr_IRQManager::EnableIRQ(0x1D);
			//
			if (edroom_can_drv_pending_msg() != 0)
				RemoteCommEventIRQ.Signal();

		}else endTask=1;

	}while(!endTask);


}




//*****************************************************************************
//SetComponents

void CEDROOMSystemCommSAP::SetComponents(ICUASW   *p_icuasw,
		CCEPDManager   *p_ccepdmanager,
		CCTM_ChannelCtrl   *p_cctm_channelctrl,
		RCCHK_FDIRMng   *p_rcchk_fdirmng,
		RCCBKGTCExec   *p_rccbkgtcexec){
	mp_icuasw=p_icuasw;
	mp_ccepdmanager=p_ccepdmanager;
	mp_cctm_channelctrl=p_cctm_channelctrl;
	mp_rcchk_fdirmng=p_rcchk_fdirmng;
	mp_rccbkgtcexec=p_rccbkgtcexec;
}


//*****************************************************************************
//*****************************************************************************
//Signal Translation Functions
//*****************************************************************************
//*****************************************************************************


TEDROOMSignal CEDROOMSystemCommSAP::C5BKGTCExec_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl3(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( RCCBKGTCExec::STxTM):	 signalIn=CCTM_ChannelCtrl::STxTM; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C3TM_ChannelCtrl_PTMChannelCtrl3__C5BKGTCExec_PTMChannelCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCTM_ChannelCtrl::STMQueued):	 signalIn=RCCBKGTCExec::STMQueued; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C2EPDManager_PBKGExecCtrl__C5BKGTCExec_PBKGExecCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCEPDManager::SBKGTC):	 signalIn=RCCBKGTCExec::SBKGTC; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C5BKGTCExec_PBKGExecCtrl__C2EPDManager_PBKGExecCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C2EPDManager_PHK_FDIRCtrl__C4HK_FDIRMng_PHK_FDIRCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCEPDManager::SHK_FDIR_TC):	 signalIn=RCCHK_FDIRMng::SHK_FDIR_TC; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C4HK_FDIRMng_PHK_FDIRCtrl__C2EPDManager_PHK_FDIRCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( RCCHK_FDIRMng::SRecAction):	 signalIn=CCEPDManager::SRecAction; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C3TM_ChannelCtrl_PTMChannelCtrl2__C4HK_FDIRMng_PTMChannelCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCTM_ChannelCtrl::STMQueued):	 signalIn=RCCHK_FDIRMng::STMQueued; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C4HK_FDIRMng_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl2(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( RCCHK_FDIRMng::STxTM):	 signalIn=CCTM_ChannelCtrl::STxTM; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C2EPDManager_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCEPDManager::STxTM):	 signalIn=CCTM_ChannelCtrl::STxTM; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}

TEDROOMSignal CEDROOMSystemCommSAP::C3TM_ChannelCtrl_PTMChannelCtrl__C2EPDManager_PTMChannelCtrl(TEDROOMSignal signalOut){

	TEDROOMSignal signalIn;

	switch(signalOut){

	case( CCTM_ChannelCtrl::STMQueued):	 signalIn=CCEPDManager::STMQueued; break;

	default: signalIn=(TEDROOMSignal)(-1); break;

	}
	return signalIn;

}



//*****************************************************************************
//RegisterInterfaces

void CEDROOMSystemCommSAP::RegisterInterfaces(){

	// Register Interface for Component 1
	//duda: intefaces comentadas?
	m_localCommSAP.RegisterInterface(1, mp_icuasw->Timer, mp_icuasw);

	// Register Interface for Component 2//EPDManager
	m_localCommSAP.RegisterInterface(1, mp_ccepdmanager->BKGExecCtrl, mp_ccepdmanager);
	m_localCommSAP.RegisterInterface(2, mp_ccepdmanager->HK_FDIRCtrl, mp_ccepdmanager);
	m_localCommSAP.RegisterInterface(3, mp_ccepdmanager->RxTC, mp_ccepdmanager);
	m_localCommSAP.RegisterInterface(4, mp_ccepdmanager->TMChannelCtrl, mp_ccepdmanager);

	// Register Interface for Component 3//TM_ChannelCtrl
	m_localCommSAP.RegisterInterface(1, mp_cctm_channelctrl->TMChannelCtrl3, mp_cctm_channelctrl);
	m_localCommSAP.RegisterInterface(2, mp_cctm_channelctrl->TMChannelCtrl2, mp_cctm_channelctrl);
	m_localCommSAP.RegisterInterface(3, mp_cctm_channelctrl->TMChannelCtrl, mp_cctm_channelctrl);

	// Register Interface for remote Component 4 //HK_FDIR
	m_localCommSAP.RegisterInterface(1, mp_rcchk_fdirmng->HK_FDIRCtrl, mp_rcchk_fdirmng);
	m_localCommSAP.RegisterInterface(2, mp_rcchk_fdirmng->TMChannelCtrl, mp_rcchk_fdirmng);
	//m_localCommSAP.RegisterInterface(3, mp_rcchk_fdirmng->HK_FDIRTimer, mp_rcchk_fdirmng);

	// Register Interface for remote Component 5 //BKTCExec
	m_localCommSAP.RegisterInterface(1, mp_rccbkgtcexec->BKGExecCtrl, mp_rccbkgtcexec);
	m_localCommSAP.RegisterInterface(2, mp_rccbkgtcexec->TMChannelCtrl, mp_rccbkgtcexec);

}


//*****************************************************************************
////SetLocalConnections

void CEDROOMSystemCommSAP::SetLocalConnections(){

	/*
	m_localCommSAP.Connect(mp_rccbkgtcexec->TMChannelCtrl, mp_cctm_channelctrl->TMChannelCtrl3, connections[0],
					C5BKGTCExec_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl3, 
					C3TM_ChannelCtrl_PTMChannelCtrl3__C5BKGTCExec_PTMChannelCtrl);

	m_localCommSAP.Connect(mp_ccepdmanager->BKGExecCtrl, mp_rccbkgtcexec->BKGExecCtrl, connections[1],
					C2EPDManager_PBKGExecCtrl__C5BKGTCExec_PBKGExecCtrl, 
					C5BKGTCExec_PBKGExecCtrl__C2EPDManager_PBKGExecCtrl);

	m_localCommSAP.Connect(mp_ccepdmanager->HK_FDIRCtrl, mp_rcchk_fdirmng->HK_FDIRCtrl, connections[2],
					C2EPDManager_PHK_FDIRCtrl__C4HK_FDIRMng_PHK_FDIRCtrl, 
					C4HK_FDIRMng_PHK_FDIRCtrl__C2EPDManager_PHK_FDIRCtrl);

	m_localCommSAP.Connect(mp_cctm_channelctrl->TMChannelCtrl2, mp_rcchk_fdirmng->TMChannelCtrl, connections[3],
					C3TM_ChannelCtrl_PTMChannelCtrl2__C4HK_FDIRMng_PTMChannelCtrl, 
					C4HK_FDIRMng_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl2);
	 */
	m_localCommSAP.Connect(mp_ccepdmanager->TMChannelCtrl, mp_cctm_channelctrl->TMChannelCtrl, connections[0],
			C2EPDManager_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl,
			C3TM_ChannelCtrl_PTMChannelCtrl__C2EPDManager_PTMChannelCtrl);

}



//***************************************************************************
//							CEDROOMRemoteTXChannel PUBLIC METHODS
//***************************************************************************


//***************************************************************************
//Constructor

CEDROOMRemoteTXChannel::CEDROOMRemoteTXChannel(){



}


//***************************************************************************
//send
void CEDROOMRemoteTXChannel::send(TEDROOMSignal signal,
		void *p_data,
		CEDROOMMemoryPool * p_DataPool)
{
	//Check DataPool
	if(p_DataPool && p_data)
	{
		if(p_DataPool->IsEmpty())
		{
			mp_SenderCmp->m_Mutex.Wait();

			//Data Pool Is Empty
			mp_SenderCmp->SetErrorFlag(EDROOMSendDataPoolEmpty);

			mp_SenderCmp->m_Mutex.Signal();
		}

		//DEBUG
		//todo edroom_can_drv_read_status();

		edroom_can_drv_send_edroom_message((uint8_t)signal,
				(uint8_t)mp_SenderPort->m_IdInterface,
				(uint8_t)mp_SenderCmp->m_ComponentID,
				(uint8_t)mp_ReceiverCmp->m_NomPriority,
				p_DataPool->ElementSize,
				(byte_t *) p_data);

		//DEBUG
		//todo edroom_can_drv_read_status();

		if(0!=p_DataPool->FreeData(p_data))
		{
			//Data id out of Pool!!
			mp_SenderCmp->SetErrorFlag(EDROOMDataOutOfPool);
		}
	}
	else
	{

		//DEBUG
		//todo edroom_can_drv_read_status();

		edroom_can_drv_send_edroom_message((uint8_t)signal,
						(uint8_t)mp_SenderPort->m_IdInterface,
						(uint8_t)mp_SenderCmp->m_ComponentID,
						(uint8_t)mp_ReceiverCmp->m_NomPriority,
						0, NULL);

		//DEBUG
		//todo edroom_can_drv_read_status();

	}
}



//*************************************************************************
//invoke
//(to remote)
CEDROOMMessage * CEDROOMRemoteTXChannel::invoke(TEDROOMSignal signal,
		void *p_data,
		CEDROOMMemoryPool * p_DataPool)
{

	//DEBUG
	//todo edroom_can_drv_read_status();

	CEDROOMSynchrMessage *p_Msg;
	//TEDROOMBool queuefull= false;

	Pr_SemaphoreBin *apSemSincr;

	//LocalTXChannel of the remote component port
	CEDROOMLocalTXChannel * remote_cmp_port_localtxchannel=(CEDROOMLocalTXChannel * )mp_ReceiverPort->mp_Channel;

	//Alloc Synchr Msg. It waits until the message is free, so synchr Msg Pool
	//is never empty

	p_Msg = mp_SenderCmp->m_SynchrMsgPool.AllocData();

	//Sender here is not remote because the reply is done using the local connection
	p_Msg->m_IsSenderRemote=false;


	//TODO?Complete attributes;


	//NO signal conversion here. Conversion is done in the Remote Receiver
	p_Msg->signal=(*mp_SenderToReceiverSignalTranslator)(signal);

	//Msg Pool
	p_Msg->mp_MsgPool=&mp_SenderCmp->m_SynchrMsgPool;

	//Msg Data
	p_Msg->data=p_data;

	//Msg Data Pool
	p_Msg->mp_DataPool=p_DataPool;

	//Check If Data Pool is Empty
	if(p_DataPool)
		if(p_DataPool->IsEmpty())
			mp_SenderCmp->SetErrorFlag(EDROOMInvokeDataPoolEmpty);

	//Priority
	p_Msg->priority=mp_ReceiverCmp->GetNomPriority();

	//Interface
	p_Msg->mp_Interface=mp_ReceiverPort;

	//Synchr Sem
	apSemSincr=&(p_Msg->m_SynchrSem);

	//Free Component->MsgBack, if it is not NULL
	mp_SenderCmp->EDROOMFreeMsgBackData();

	//Pointer to Msg Back;
	p_Msg->mp_MsgBack=&(mp_SenderCmp->m_MessageBack);

	//sender is waiting
	p_Msg->m_IsSenderWaiting=1;

	//****************************************************************************
	//*********************** REMOTE *********************************************
	//Set LocalTXChannel pointer to Synchronize Msg. This pointer is used replu_from_remote
	remote_cmp_port_localtxchannel->mp_SynchrMsgFromRemote=p_Msg;

	if(p_data && p_DataPool)
	{
		edroom_can_drv_send_edroom_message((uint8_t)signal, (uint8_t)mp_SenderPort->m_IdInterface, (uint8_t)mp_SenderCmp->m_ComponentID, (uint8_t)mp_ReceiverCmp->m_NomPriority
				, p_DataPool->ElementSize, (byte_t *) p_data);
	}
	else
	{
		edroom_can_drv_send_edroom_message((uint8_t)signal, (uint8_t)mp_SenderPort->m_IdInterface, (uint8_t)mp_SenderCmp->m_ComponentID, (uint8_t)mp_ReceiverCmp->m_NomPriority
						, 0, NULL);
	}

	//DEBUG
	//todo edroom_can_drv_read_status();

	//Put msg in queue
	//mp_ReceiverCmp->m_Mutex.Wait();
/*
	if(mp_ReceiverCmp->m_MsgQueue.IsFull())
	{
		CEDROOMMessage* auxMsg;
		queuefull=true;
		//Msg Pool Is Empty
		mp_ReceiverCmp->SetErrorFlag(EDROOMMsgQueueFull);
		p_Msg->mp_MsgBack->signal=0;//timeout
		p_Msg->mp_MsgBack->data=NULL;
		p_Msg->mp_MsgBack->mp_DataPool=NULL;
		auxMsg=(CEDROOMMessage*)p_Msg;
		mp_ReceiverCmp->EDROOMFreeMessage(auxMsg);

	}
	else
		mp_ReceiverCmp->m_MsgQueue.In(p_Msg);

	mp_ReceiverCmp->m_Mutex.Signal();
*/
	//if(!queuefull)
	//{
	//Wait reply if message has been sent (queue is not full)
	apSemSincr->Wait();
	//}

	CEDROOMMessage* auxMsg;
	auxMsg=(CEDROOMMessage*)p_Msg;
	mp_ReceiverCmp->EDROOMFreeMessage(auxMsg);

	//return the pointer
	return(&(mp_SenderCmp->m_MessageBack));

}



//*****************************************************************************
//reply

void CEDROOMRemoteTXChannel::reply_to_remote(TEDROOMSignal signal, void * p_data
		, CEDROOMMemoryPool *p_DataPool)
{
	//Check DataPool
	if(p_data && p_DataPool)
	{
		if(p_DataPool->IsEmpty())
		{
			mp_SenderCmp->m_Mutex.Wait();

			//Data Pool is Empty
			mp_SenderCmp->SetErrorFlag(EDROOMReplyDataPoolEmpty);

			mp_SenderCmp->m_Mutex.Signal();
			//¿No debería terminar aquí la función debido a un error?
		}

		//DEBUG
		//todo edroom_can_drv_read_status();

		edroom_can_drv_send_edroom_message((uint8_t)signal, (uint8_t)mp_SenderPort->m_IdInterface
				, (uint8_t)mp_SenderCmp->m_ComponentID, (uint8_t)mp_ReceiverCmp->m_NomPriority
				, p_DataPool->ElementSize, (byte_t *) p_data);

		//DEBUG
		//todo edroom_can_drv_read_status();

		if(0!=p_DataPool->FreeData(p_data))
		{
			//Data is out of Pool!!!
			mp_SenderCmp->SetErrorFlag(EDROOMDataOutOfPool);
		}
	}
	else
	{
		//NO DATA in the reply
		edroom_can_drv_send_edroom_message((uint8_t)signal, (uint8_t)mp_SenderPort->m_IdInterface
				, (uint8_t)mp_SenderCmp->m_ComponentID, (uint8_t)mp_ReceiverCmp->m_NomPriority, 0, NULL);
	}

}


//***************************************************************************
// *****************        Connect *******************************


//***************************************************************************
// *****************        RegisterInterface *******************************



TEDROOMInt32 CEDROOMRemoteCommSAP::RegisterInterface( TEDROOMInterfaceID id
		, CEDROOMInterface & interf
		, CEDROOMComponent * component){



	interf.m_IdInterface=id; //interface id

	interf.mp_Component=component; 	// component pointer





	return(0);
}


void CEDROOMRemoteCommSAP::Connect(CEDROOMInterface &inter1
		,CEDROOMInterface &inter2
		, CEDROOMRemoteConnection &connection
		, TEDROOMSignal (f1) (TEDROOMSignal )
		, TEDROOMSignal  (f2) (TEDROOMSignal )){

	//Connect ports


	connection.m_Channel1.mp_SenderPort=&inter1;     //puertos que la forman

	connection.m_Channel1.mp_ReceiverPort=&inter2;     //puertos que la forman

	connection.m_Channel2.mp_SenderPort=&inter2;     //puertos que la forman

	connection.m_Channel2.mp_ReceiverPort=&inter1;     //puertos que la forman

	// pointers to channels

	inter1.mp_Channel=&connection.m_Channel1;
	inter2.mp_Channel=&connection.m_Channel2;


	// pointer to components

	connection.m_Channel1.mp_SenderCmp=inter1.mp_Component;
	connection.m_Channel1.mp_ReceiverCmp=inter2.mp_Component;
	connection.m_Channel2.mp_SenderCmp=inter2.mp_Component;
	connection.m_Channel2.mp_ReceiverCmp=inter1.mp_Component;


	//Signal conversion

	connection.m_Channel1.mp_SenderToReceiverSignalTranslator=f1;
	connection.m_Channel2.mp_SenderToReceiverSignalTranslator=f2;





}


//*****************************************************************************
////SetRemoteConnections

void CEDROOMSystemCommSAP::SetRemoteConnections(){

	//Init CAN Configuration
	//edroom_can_drv_config();
	m_remoteCommSAP.Connect(mp_cctm_channelctrl->TMChannelCtrl3,mp_rccbkgtcexec->TMChannelCtrl, remote_connections[0],
			C3TM_ChannelCtrl_PTMChannelCtrl3__C5BKGTCExec_PTMChannelCtrl,
			C5BKGTCExec_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl3);

	m_remoteCommSAP.Connect(mp_ccepdmanager->BKGExecCtrl, mp_rccbkgtcexec->BKGExecCtrl, remote_connections[1],
			C2EPDManager_PBKGExecCtrl__C5BKGTCExec_PBKGExecCtrl,
			C5BKGTCExec_PBKGExecCtrl__C2EPDManager_PBKGExecCtrl);

	m_remoteCommSAP.Connect(mp_ccepdmanager->HK_FDIRCtrl, mp_rcchk_fdirmng->HK_FDIRCtrl, remote_connections[2],
			C2EPDManager_PHK_FDIRCtrl__C4HK_FDIRMng_PHK_FDIRCtrl,
			C4HK_FDIRMng_PHK_FDIRCtrl__C2EPDManager_PHK_FDIRCtrl);

	m_remoteCommSAP.Connect(mp_cctm_channelctrl->TMChannelCtrl2, mp_rcchk_fdirmng->TMChannelCtrl, remote_connections[3],
			C3TM_ChannelCtrl_PTMChannelCtrl2__C4HK_FDIRMng_PTMChannelCtrl,
			C4HK_FDIRMng_PTMChannelCtrl__C3TM_ChannelCtrl_PTMChannelCtrl2);

}

//*****************************************************************************
////SetConnections

void CEDROOMSystemCommSAP::SetConnections(){

	SetLocalConnections();
	SetRemoteConnections();

}

//*****************************************************************************
////CEDROOMSystemDeployment Constructor

CEDROOMSystemDeployment::CEDROOMSystemDeployment(){

#ifdef CONFIG_EDROOMSL_ADD_TRACE
#endif
	systemMemory.SetMemory();

}

//*****************************************************************************
////Config

void CEDROOMSystemDeployment::Config(ICUASW   *p_icuasw,
		CCEPDManager   *p_ccepdmanager,
		CCTM_ChannelCtrl   *p_cctm_channelctrl,
		RCCHK_FDIRMng   *p_rcchk_fdirmng,
		RCCBKGTCExec   *p_rccbkgtcexec){

	mp_icuasw=p_icuasw;
	mp_ccepdmanager=p_ccepdmanager;
	mp_cctm_channelctrl=p_cctm_channelctrl;
	mp_rcchk_fdirmng=p_rcchk_fdirmng;
	mp_rccbkgtcexec=p_rccbkgtcexec;
	//Init CAN Configuration
	edroom_can_drv_config();
	systemCommSAP.SetComponents(	p_icuasw,
			p_ccepdmanager,
			p_cctm_channelctrl,
			p_rcchk_fdirmng,
			p_rccbkgtcexec);

	systemCommSAP.RegisterInterfaces();
	systemCommSAP.SetConnections();

}

//*****************************************************************************
////StartComponents

void CEDROOMSystemDeployment::StartComponents(){
	mp_icuasw->EDROOMStart();
	mp_ccepdmanager->EDROOMStart();
	mp_cctm_channelctrl->EDROOMStart();
	mp_rcchk_fdirmng->EDROOMStart();
	mp_rccbkgtcexec->EDROOMStart();

}

//*****************************************************************************
////Start

void CEDROOMSystemDeployment::Start(){

	//Install CAN IRQ HANDLER, Vector 0x1D;

	Pr_IRQManager::InstallIRQHandler(CEDROOMSystemCommSAP::RemoteCommIRQHandler,1,0x1D);

	Pr_Task RemoteComm(CEDROOMSystemCommSAP::RemoteCommIRQBottomHalfTask,EDROOMprioURGENT,1024*8);

#ifdef CONFIG_EDROOMBP_DEPLOYMENT_NEED_TASK

	Pr_Task MainTask(CEDROOMSystemDeployment::main_task,EDROOMprioMINIMUM,1024*16);

	kernel.Start();

#else

	StartComponents();

	kernel.Start();

	MainWait(*mp_icuasw,
			*mp_ccepdmanager,
			*mp_cctm_channelctrl,
			*mp_rcchk_fdirmng,
			*mp_rccbkgtcexec);


#endif

}

#ifdef CONFIG_EDROOMBP_DEPLOYMENT_NEED_TASK

extern CEDROOMSystemDeployment systemDeployment;


//*****************************************************************************
////main_task


Pr_TaskRV_t CEDROOMSystemDeployment::main_task(Pr_TaskP_t){

	systemDeployment.StartComponents();
	MainWait(*systemDeployment.mp_icuasw,
			*systemDeployment.mp_ccepdmanager,
			*systemDeployment.mp_cctm_channelctrl,
			*systemDeployment.mp_rcchk_fdirmng,
			*systemDeployment.mp_rccbkgtcexec);

}
#endif
